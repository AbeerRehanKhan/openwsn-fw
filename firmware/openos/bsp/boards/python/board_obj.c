/**
\brief PC-specific definition of the "board" bsp module.

\author Thomas Watteyne <watteyne@eecs.berkeley.edu>, April 2012.
*/

#include "board_obj.h"
// bsp modules
#include "debugpins_obj.h"
#include "leds_obj.h"
#include "uart_obj.h"
#include "bsp_timer_obj.h"
#include "radio_obj.h"
#include "radiotimer_obj.h"
#include "eui64_obj.h"

//=========================== variables =======================================

//=========================== prototypes ======================================

//=========================== public ==========================================

void board_init(OpenMote* self) {

   // initialize bsp modules
 debugpins_init(self);
 leds_init(self);
 uart_init(self);
 bsp_timer_init(self);
 radio_init(self);
 radiotimer_init(self);
   
   // send request to server and get reply
   /*
   opensim_client_sendAndWaitForAck(OPENSIM_CMD_board_init,
                                    0,
                                    0,
                                    0,
                                    0);
   */
   // TODO: replace by call to Python
}

void board_sleep(OpenMote* self) {
   int  pkType;
   int  paramLen;
   //char rxBuffer[OPENCLIENT_BUFSIZE];
   
   // send indication to the serve that CPU is going to sleep
   /*
   opensim_client_send(OPENSIM_CMD_board_sleep,
                                    0,
                                    0);
   */
   // TODO: replace by call to Python
   
   // at this point the emulated mote is sleep. The only thing which can wake
   // it up is an interrupt, which is generated by the server. We therefore
   // sit here, waiting for a packet from the server.
   /*
   opensim_client_waitForPacket(&pkType,
                                (char*)&rxBuffer,
                                sizeof(rxBuffer),
                                &paramLen);
   */
   // TODO: replace by call to Python
   
   // we now call the handler of that packet type, which executes whatever it
   // has to execute. This is exactly the same behavior as on a mote.
   /*
   opensim_cmdHandler_handle(pkType,paramLen,rxBuffer);
   */
   // TODO: replace by call to Python
   
   // after the handler is done, we exit this function. In OpenOS, this causes
   // the scheduler to take over, execute whatever tasks were queued up, and
   // call this function again.
}

void board_reset(OpenMote* self) {
   /*
   opensim_client_send(OPENSIM_CMD_board_reset,
                                    0,
                                    0);
   */
   // TODO: replace by call to Python
}

//=========================== private =========================================
